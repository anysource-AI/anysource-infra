# yaml-language-server: $schema=values.schema.json
# Global configuration
global:
  domain: "mcp.example.com"
  environment: "production"
  # Runlayer support will provide this
  auth_client_id: "your-auth-client-id"
  # OAuth Broker URL (optional, set to empty string to disable)
  oauth_broker_url: ""
  # Version URL endpoint for version information (optional)
  version_url: "https://anysource-version.s3.amazonaws.com/version.json"
  security:
    allowInsecureImages: true
  # Deployment identification for telemetry
  deployment:
    # Customer identifier (defaults to global.domain if empty)
    customerId: ""
    # Infrastructure version for tracking deployments (defaults to Chart.Version if empty)
    # Useful for correlating errors with infrastructure changes
    infraVersion: ""

# Name overrides
# Provide a name in place of the chart name
nameOverride: ""
# Provide a name to substitute for the full names of resources
fullnameOverride: ""

# Image configuration
image:
  backend:
    repository: public.ecr.aws/anysource/anysource-api
    tag: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    # Example: pullSecrets:
    #   - name: regcred
  frontend:
    repository: public.ecr.aws/anysource/anysource-web
    tag: ""
    pullPolicy: IfNotPresent
    pullSecrets: []
    # Example: pullSecrets:
    #   - name: regcred

# Backend service configuration
backend:
  name: backend
  replicas: 2
  port: 8000

  # Resource configuration
  resources:
    requests:
      cpu: 4000m
      memory: 8192Mi
    limits:
      memory: 8192Mi

  # Health checks
  livenessProbe:
    httpGet:
      path: /api/v1/utils/health-check/
      port: 8000
    initialDelaySeconds: 60
    periodSeconds: 30
    timeoutSeconds: 10
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /api/v1/utils/health-check/
      port: 8000
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  # Environment variables
  env:
    # WORKERS: "1" # Optional, will default to the number of CPUs on the node
    HOST: "0.0.0.0"
    PORT: "8000"
    # AWS region for Bedrock and other AWS services
    AWS_REGION: "us-east-1" # Default region, override in production values
    AWS_DEFAULT_REGION: "us-east-1" # Default region, override in production values
    # Bedrock guardrail ARN for prompt attack detection
    BEDROCK_GUARDRAIL_ARN: "" # Get from Terraform EKS module output
    # Database connection pool settings
    DB_POOL_SIZE: "50" # Number of connections to maintain in the pool
    DB_MAX_OVERFLOW: "50" # Additional connections beyond pool_size (total: 100)
    DB_POOL_TIMEOUT: "30" # Seconds to wait for a connection
    DB_POOL_RECYCLE: "3600" # Seconds before recreating connections (1 hour)
    DB_POOL_PRE_PING: "true" # Test connections before use
    # Tokenizers configuration for LlamaFirewall parallel processing
    TOKENIZERS_PARALLELISM: "true"

  # Secrets (will be created from values)
  # IMPORTANT: In production, use helm-fetch-vault-credentials.sh to fetch from WorkOS Vault
  # See docs/deployment-guide.md for complete workflow
  secrets:
    SECRET_KEY: "your-secret-key-here-change-in-production"
    MASTER_SALT: "your-master-salt-here-change-in-production"
    AUTH_API_KEY: "sk_live_your_auth_api_key_here"
    # Sentry DSN for error tracking
    SENTRY_DSN: ""

  # Configuration (non-sensitive environment variables)
  config: {}

# Frontend service configuration
frontend:
  name: frontend
  replicas: 2
  port: 80

  # Resource configuration
  resources:
    requests:
      cpu: 1000m
      memory: 2048Mi
    limits:
      memory: 2048Mi

  # Health checks
  livenessProbe:
    httpGet:
      path: /
      port: 80
    initialDelaySeconds: 30
    periodSeconds: 30
    timeoutSeconds: 10
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /
      port: 80
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

# Database prestart init container
prestart:
  enabled: true
  image:
    repository: public.ecr.aws/anysource/anysource-api
    tag: ""
    pullPolicy: IfNotPresent
  command: ["bash"]
  args: ["scripts/prestart.sh"]
  resources:
    requests:
      cpu: 1000m
      memory: 2048Mi
    limits:
      memory: 2048Mi

# HPA configuration
hpa:
  backend:
    enabled: true
    minReplicas: 3
    maxReplicas: 20
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80

  frontend:
    enabled: true
    minReplicas: 3
    maxReplicas: 20
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80

# Service configuration
service:
  backend:
    type: ClusterIP
    port: 8000
    targetPort: 8000
  frontend:
    type: ClusterIP
    port: 80
    targetPort: 80

# Ingress configuration (ALB by default)
ingress:
  enabled: true
  className: "alb"
  # HTTPS redirect control:
  # - false: Disable redirects (default when cert-manager is enabled for HTTP-01 challenges)
  # - true: Force redirects (automatically enabled when cert-manager is disabled)
  # Note: Template conditionally applies alb.ingress.kubernetes.io/ssl-redirect annotation
  forceHttps: true
  annotations:
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
    alb.ingress.kubernetes.io/ssl-policy: ELBSecurityPolicy-TLS-1-2-2017-01
    alb.ingress.kubernetes.io/load-balancer-name: "anysource-production"
  tls:
    enabled: false
    secretName: anysource-tls

# PostgreSQL configuration with Bitnami Legacy Images
postgresql:
  enabled: false
  fullnameOverride: "postgresql"

  # Use Bitnami Legacy Images (for compatibility)
  image:
    registry: docker.io
    repository: bitnamilegacy/postgresql
    tag: "17.6.0-debian-12-r4"
    pullPolicy: IfNotPresent

  # Volume permissions using legacy image
  volumePermissions:
    enabled: true
    image:
      registry: docker.io
      repository: bitnamilegacy/os-shell
      tag: "12-debian-12-r51"
      pullPolicy: IfNotPresent

  auth:
    postgresPassword: "postgres123"
    username: "postgres"
    password: "postgres123"
    database: "postgres"
    replicationPassword: "replication123"

  # High Availability Configuration
  architecture: replication

  # Primary server configuration
  primary:
    resources:
      requests:
        cpu: 4000m
        memory: 8192Mi
      limits:
        cpu: 4000m
        memory: 8192Mi
    persistence:
      enabled: true
      size: 10Gi
      storageClass: ebs-gp3

  # Read replicas configuration for HA
  readReplicas:
    replicaCount: 1
    resources:
      requests:
        cpu: 4000m
        memory: 8192Mi
      limits:
        cpu: 4000m
        memory: 8192Mi
    persistence:
      enabled: true
      size: 5Gi
      storageClass: ebs-gp3

# Redis configuration with Bitnami Legacy Images
redis:
  enabled: false
  fullnameOverride: "redis"

  # Use Bitnami Legacy Images (for compatibility)
  image:
    registry: docker.io
    repository: bitnamilegacy/redis
    tag: "7.4.3-debian-12-r0"
    pullPolicy: IfNotPresent

  # Metrics using legacy image
  metrics:
    enabled: true
    image:
      registry: docker.io
      repository: bitnamilegacy/redis-exporter
      tag: "1.76.0-debian-12-r0"
      pullPolicy: IfNotPresent

  auth:
    enabled: true
    password: "redis123"

  master:
    resources:
      requests:
        cpu: 1000m
        memory: 2048Mi
      limits:
        cpu: 1000m
        memory: 2048Mi
    persistence:
      enabled: true
      size: 5Gi
      storageClass: ebs-gp3

  replica:
    replicaCount: 1
    resources:
      requests:
        cpu: 1000m
        memory: 2048Mi
      limits:
        cpu: 1000m
        memory: 2048Mi
    persistence:
      enabled: true
      size: 8Gi
      storageClass: ebs-gp3

# External database configuration (for production)
externalDatabase:
  enabled: true
  type: postgresql
  host: ""
  port: 5432
  database: "postgres"
  username: "postgres"
  password: ""
  # Password should be provided via secret
  existingSecret: ""
  existingSecretPasswordKey: "password"

# External Redis configuration (for production)
externalRedis:
  enabled: true
  host: ""
  port: 6379
  password: ""
  # Password should be provided via secret
  existingSecret: ""
  existingSecretPasswordKey: "password"

# Cert-manager configuration
certManager:
  enabled: false
  issuer:
    name: letsencrypt-prod
    email: "your-email@example.com"
    server: https://acme-v02.api.letsencrypt.org/directory

# AWS ACM certificate (for AWS environments)
# When enabled, this will use an existing ACM certificate instead of cert-manager
# Requirements:
# 1. Set certManager.enabled: false
# 2. Set awsCertificate.enabled: true
# 3. Provide the ACM certificate ARN
# 4. Set ingress.tls.enabled: false (ACM handles TLS termination)
# 5. HTTPS redirects are automatically enabled when cert-manager is disabled
awsCertificate:
  enabled: false
  arn: "" # Example: "arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012"

# Security context for Bitnami Legacy Images compatibility
securityContext:
  runAsNonRoot: false
  runAsUser: 0
  runAsGroup: 1001
  readOnlyRootFilesystem: false

podSecurityContext:
  fsGroup: 1001
  seccompProfile:
    type: RuntimeDefault

# Service account
serviceAccount:
  annotations:
    # Add IRSA role annotation for AWS Bedrock permissions
    # This should be set to the output from terraform-eks: anysource_service_account_role_arn
    # Example: eks.amazonaws.com/role-arn: "arn:aws:iam::123456789012:role/project-environment-anysource-role"
    eks.amazonaws.com/role-arn: ""

# Pod annotations
podAnnotations: {}

# Pod labels
# Custom labels to add to all pods
podLabels:
  {}
  # Example:
  # environment: production
  # team: platform

# Node selector, tolerations and affinity
nodeSelector: {}
tolerations: []
affinity: {}

# Network policies
networkPolicy:
  enabled: false
  # Optional: CIDR of your VPC to allow backend egress to RDS (5432)
  # and ElastiCache/Redis (6379). Example: "10.0.0.0/16"
  vpcCidr: ""

# Storage Class Configuration
storageClass:
  enabled: true
  name: ebs-gp3
  isDefault: false
  provisioner: ebs.csi.aws.com
  volumeBindingMode: WaitForFirstConsumer
  allowVolumeExpansion: true
  reclaimPolicy: Delete
  parameters:
    type: gp3
    encrypted: "true"
    # Optional: Uncomment and adjust for production workloads
    iops: "3000"
    throughput: "125"
    kmsKeyId: ""
    # Additional parameters can be added here
    additionalParameters: {}

# ========================================
# SCIM / Directory Sync Configuration
# ========================================
directorySync:
  # Enable directory sync CronJob (event-based incremental sync)
  enabled: true

  # Cron schedule for event-based sync (defaults to "*/10 * * * *" - every 10 minutes)
  # Override with custom schedule if needed:
  # schedule: "*/15 * * * *"  # every 15 minutes
  # schedule: "0 */2 * * *"   # every 2 hours
  # schedule: "0 0 * * *"     # daily at midnight

  # Resource configuration for sync jobs
  resources:
    requests:
      cpu: 1000m
      memory: 2048Mi
    limits:
      memory: 2048Mi

  # Reconciliation job configuration (full state sync from WorkOS)
  reconciliation:
    # Enable reconciliation CronJob
    enabled: false

    # Cron schedule for reconciliation (defaults to "0 4 * * *" - daily at 4 AM)
    # Override with custom schedule if needed:
    # schedule: "0 3 * * *"     # daily at 3 AM
    # schedule: "0 4 * * 0"     # weekly on Sunday at 4 AM
    schedule: "0 4 * * *"

    # Resource configuration for reconciliation jobs (may need more resources than event sync)
    resources:
      requests:
        cpu: 1000m
        memory: 2048Mi
      limits:
        memory: 2048Mi

# ========================================
# Sentry Relay Configuration
# ========================================
# Sentry Relay processes telemetry within customer infrastructure before forwarding to Sentry SaaS
# This ensures telemetry data stays within your VPC for privacy and compliance
#
# Graceful Degradation:
# If relay credentials are not available in WorkOS Vault, set enabled: false to deploy without Sentry.
# The helm-fetch-vault-credentials.sh script automatically sets this flag based on credential availability.
#
# How it works:
# 1. Backend is configured with SENTRY_DSN (your Sentry project DSN) in secrets
# 2. Backend automatically sets SENTRY_RELAY_HOST="sentry-relay:<port>" (from config below)
# 3. Backend replaces the host in SENTRY_DSN with the relay endpoint
# 4. All telemetry routes through local Relay before going to Sentry SaaS

relay:
  # Enable/disable Sentry Relay deployment
  # Set to false if credentials are not available (graceful degradation)
  # helm-fetch-vault-credentials.sh automatically manages this flag
  enabled: true

  # Image configuration
  image:
    repository: ghcr.io/getsentry/relay
    tag: "25.10.0"
    pullPolicy: IfNotPresent
    pullSecrets: []
    # Example: pullSecrets:
    #   - name: regcred

  # Number of relay replicas (run 2+ for high availability)
  replicas: 2

  # Port relay listens on
  port: 3000

  # Resource configuration
  # Note: Sentry Operating Guidelines recommend minimum 2GB RAM per container
  # See: https://docs.sentry.io/product/relay/operating-guidelines/
  resources:
    requests:
      cpu: 1000m
      memory: 2048Mi
    limits:
      memory: 2048Mi

  # Health checks
  livenessProbe:
    httpGet:
      path: /api/relay/healthcheck/live/
      port: 3000
    initialDelaySeconds: 10
    periodSeconds: 30
    timeoutSeconds: 5
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /api/relay/healthcheck/ready/
      port: 3000
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  # Relay configuration (managed mode)
  config:
    mode: managed
    upstream: "https://o4509836808028160.ingest.us.sentry.io"
    logLevel: info
    logFormat: json

  # Sentry Relay credentials
  # IMPORTANT: Do not hardcode these values in production!
  # Use the helm-fetch-vault-credentials.sh script to automatically fetch from WorkOS Vault:
  #
  #   export WORKOS_API_KEY="sk_live_..."
  #   VALUES_FILE=$(./scripts/helm-fetch-vault-credentials.sh)
  #   helm install anysource ./chart -f production-values.yaml -f "$VALUES_FILE"
  #
  # For testing/development only:
  secrets:
    public_key: "your-relay-public-key-here"
    secret_key: "your-relay-secret-key-here"
    id: "your-relay-id-here"

  # Vault integration for automatic credential fetching via init container
  # When enabled, an init container will fetch credentials from WorkOS Vault
  # before the relay starts, writing them to a shared memory volume
  # Uses AUTH_API_KEY from backend.secrets to authenticate with WorkOS Vault
  vault:
    # Enable automatic credential fetching via init container
    enabled: true

  # HPA configuration for relay
  hpa:
    enabled: true
    minReplicas: 2
    maxReplicas: 6
    targetCPUUtilizationPercentage: 70
    targetMemoryUtilizationPercentage: 80

# ========================================
# Deployment Telemetry Configuration
# ========================================
# Automatic deployment tracking via Helm hooks
# Sends deployment completion events to Sentry for observability
#
# How it works:
# 1. post-upgrade hook: Sends success event after successful deployment
# 2. post-rollback hook: Sends failure event if deployment fails (requires --atomic flag)
#
# Telemetry data includes:
# - Customer ID (from global.domain)
# - Infrastructure version (from global.deployment.infraVersion)
# - Deployment status (success/failure)
# - Duration and timestamp
#
# Note: Telemetry gracefully degrades if SENTRY_DSN is not configured
telemetry:
  # Enable deployment telemetry hooks
  enabled: true
