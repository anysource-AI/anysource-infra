# Kubernetes Production values file (non-AWS managed services)
# - Uses in-cluster Bitnami PostgreSQL (HA) and Redis
# - Uses nginx Ingress and cert-manager for TLS
# - Mirrors production-grade resources and security settings

global:
  domain: "mcp.example.com"
  environment: "production"

# In-cluster PostgreSQL (HA via Bitnami chart)
postgresql:
  enabled: true

  # High Availability Configuration
  architecture: replication

  auth:
    postgresPassword: "CHANGE-THIS-IN-PRODUCTION"
    username: "postgres"
    password: "CHANGE-THIS-IN-PRODUCTION"
    database: "postgres"
    replicationPassword: "CHANGE-THIS-REPLICATION-PASSWORD-IN-PRODUCTION"

  # Primary server configuration (production-grade)
  primary:
    persistence:
      enabled: true
      size: 100Gi
      storageClass: ebs-gp3

  # Read replicas for HA
  readReplicas:
    replicaCount: 3
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
      limits:
        cpu: 500m
        memory: 1Gi
    persistence:
      enabled: true
      size: 100Gi
      storageClass: ebs-gp3

# In-cluster Redis (Bitnami chart)
redis:
  enabled: true
  auth:
    enabled: true
    password: "CHANGE-THIS-IN-PRODUCTION"
  master:
    persistence:
      enabled: true
      size: 20Gi
      storageClass: ebs-gp3
  replica:
    replicaCount: 2
    persistence:
      enabled: true
      size: 10Gi
      storageClass: ebs-gp3

# Ingress configuration - inherits from base values.yaml
# ALB ingress is already configured with proper annotations and TLS
ingress:
  # Production overrides only (base configuration is in values.yaml)
  enabled: true
  forceHttps: true  # Force HTTPS redirects in production

# Enable cert-manager for production TLS (Letâ€™s Encrypt prod)
certManager:
  enabled: true
  issuer:
    name: letsencrypt-prod
    email: "admin@example.com"
    server: https://acme-v02.api.letsencrypt.org/directory

# Cert-manager configuration - inherits from base values.yaml
# AWS certificate configuration is already defined in values.yaml

# Backend (FastAPI)
backend:
  replicas: 3
  resources:
    requests:
      cpu: 1000m
      memory: 2Gi
    limits:
      cpu: 1000m
      memory: 2Gi

  # Production configuration (non-sensitive)
  config:
    BACKEND_CORS_ORIGINS: "https://mcp.example.com"
    APP_URL: "https://mcp.example.com"

  # Production secrets - set via secure CI/secret manager for real deployments
  secrets:
    FIRST_SUPERUSER: "admin@example.com"
    FIRST_SUPERUSER_PASSWORD: "CHANGE-THIS-IN-PRODUCTION"
    SECRET_KEY: "CHANGE-THIS-TO-A-SECURE-SECRET-KEY-MINIMUM-32-CHARACTERS"
    MASTER_SALT: "CHANGE-THIS-TO-A-SECURE-MASTER-SALT-MINIMUM-32-CHARACTERS"

# Frontend (Nginx)
frontend:
  replicas: 3
  resources:
    requests:
      cpu: 500m
      memory: 1Gi
    limits:
      cpu: 500m
      memory: 1Gi

# HPA configuration for production
hpa:
  backend:
    enabled: true
    minReplicas: 3
    maxReplicas: 20
  frontend:
    enabled: true
    minReplicas: 3
    maxReplicas: 10

# Security: production-hardening
securityContext:
  runAsNonRoot: true
  runAsUser: 1000
  runAsGroup: 1000
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL

podSecurityContext:
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault
  supplementalGroups: [1000]

# Enable network policies for production
networkPolicy:
  enabled: true

# Service account (no cloud IAM annotations required here)
serviceAccount:
  create: true
  name: "anysource-sa"

# Scheduling preferences (generic, non-cloud specific)
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - anysource
          topologyKey: kubernetes.io/hostname

# Disable AWS-specific StorageClass provisioning; use cluster default (e.g., standard)
storageClass:
  enabled: false
